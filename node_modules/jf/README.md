JF
==

A minimalist fork/join library for Javascript.

This codebase is unstable and should not be used at this time.

Version 0.2.x is an incompatable rebuild from version 0.1.x. 

Usage
==
```js
var start = require('jf').start,
	fs = require('fs');

var table = {};

//Start the process with a start() call, passing the initial setup function.
//The initial setup function will be provided one argument, task, a reference to the current task.
start(function(task) {
	//For every fork, create a new callback via nextCallback()
	//The fork must accept a node-style callback, i.e. function(err, result_1, result_2, ...)
	fs.readdir(__dirname, task.nextCallback());
})
//Continue the process with then() calls.
//Results of each fork are passed as an argument after a task and error reference in the order their callbacks were first requested.
.then(function(task, err, files) {
	//The first error occured when invoking the previous setup function or any of its forks is passed as err.
	if(err) {
		//Thrown errors will stop the current setup function and are passed to the next setup.
		throw err;
	}
	for(var i = 0; i < files.length; i++) {
		var path = __dirname + "/" + files[i];
		//Add immediate values to the next setup function via push().
		task.push(path);
		//You can also use cb() as an alias for nextCallback().
		fs.stat( path, task.cb() );
	}
})
//Iterate through fork results with the each() call.
//The setup function will be parsed and only passed values for each argument provided after task and err.
//The function will be invoked enough times to iterate through all available fork results.
//If the previous setup results in an error the each() function will only be called once.
.each(function(task, err, path, stat) {
	if(err) {
		throw err;
	}
	table[path] = stat;
})
//While not required, it is recommended that you complete a process with an end() call.
//An end() block is similar to then() and each() but fork results are preceeded only by an error reference, task is omitted.
//Also, while start(), then() and each() are chainable, end() is not.
.end(function(err) {
	if(err) {
		//Unlike then() and each(), any errors thrown in an end() block will be rethrown to assist in debugging.
		throw err;
	}
	console.log(table);
});
```