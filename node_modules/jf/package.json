{
  "name": "jf",
  "description": "A minimalist fork/join library for Javascript",
  "version": "0.2.8",
  "engines": {
    "node": ">= 0.8.0"
  },
  "author": {
    "name": "Roarke Lynch",
    "email": "roarkely@gmail.com"
  },
  "main": "./lib/jf",
  "repository": {
    "type": "git",
    "url": "https://github.com/roarkely/F.git"
  },
  "licenses": [
    {
      "type": "The MIT License",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "readme": "JF\n==\n\nA minimalist fork/join library for Javascript.\n\nThis codebase is unstable and should not be used at this time.\n\nVersion 0.2.x is an incompatable rebuild from version 0.1.x. \n\nUsage\n==\n```js\nvar start = require('jf').start,\n\tfs = require('fs');\n\nvar table = {};\n\n//Start the process with a start() call, passing the initial setup function.\n//The initial setup function will be provided one argument, task, a reference to the current task.\nstart(function(task) {\n\t//For every fork, create a new callback via nextCallback()\n\t//The fork must accept a node-style callback, i.e. function(err, result_1, result_2, ...)\n\tfs.readdir(__dirname, task.nextCallback());\n})\n//Continue the process with then() calls.\n//Results of each fork are passed as an argument after a task and error reference in the order their callbacks were first requested.\n.then(function(task, err, files) {\n\t//The first error occured when invoking the previous setup function or any of its forks is passed as err.\n\tif(err) {\n\t\t//Thrown errors will stop the current setup function and are passed to the next setup.\n\t\tthrow err;\n\t}\n\tfor(var i = 0; i < files.length; i++) {\n\t\tvar path = __dirname + \"/\" + files[i];\n\t\t//Add immediate values to the next setup function via push().\n\t\ttask.push(path);\n\t\t//You can also use cb() as an alias for nextCallback().\n\t\tfs.stat( path, task.cb() );\n\t}\n})\n//Iterate through fork results with the each() call.\n//The setup function will be parsed and only passed values for each argument provided after task and err.\n//The function will be invoked enough times to iterate through all available fork results.\n//If the previous setup results in an error the each() function will only be called once.\n.each(function(task, err, path, stat) {\n\tif(err) {\n\t\tthrow err;\n\t}\n\ttable[path] = stat;\n})\n//While not required, it is recommended that you complete a process with an end() call.\n//An end() block is similar to then() and each() but fork results are preceeded only by an error reference, task is omitted.\n//Also, while start(), then() and each() are chainable, end() is not.\n.end(function(err) {\n\tif(err) {\n\t\t//Unlike then() and each(), any errors thrown in an end() block will be rethrown to assist in debugging.\n\t\tthrow err;\n\t}\n\tconsole.log(table);\n});\n```",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/roarkely/F/issues"
  },
  "homepage": "https://github.com/roarkely/F",
  "_id": "jf@0.2.8",
  "dist": {
    "shasum": "a2c15043e0e61c1f6b9c2ec94dc5d073282f8838"
  },
  "_from": "jf@",
  "_resolved": "https://registry.npmjs.org/jf/-/jf-0.2.8.tgz"
}
