/*jslint nomen: true, white: true, node: true */
"use strict";
var Task, Process;

/**
 * Provides an interface for grouped callbacks
 * @class Task
 */
Task = function (cb) {
	//Private
	var self = this,
		callback = cb,
		results = [],
		isFinalized = false,
		criticalError = null,
		didDispatchCallback = false,
		dispatchCallbackIfComplete;

	dispatchCallbackIfComplete = function() {
		if(didDispatchCallback) {
			if(criticalError === null) {
				throw new Error("Task callback should be dispatched once.");
			}
			else {
				return;	
			}
		}
		if(isFinalized === false) {
			return;
		}

		if(criticalError) {
			didDispatchCallback = true;
			callback(self, criticalError);
			return;
		}

		var data = [],
			i;

		for(i = 0; i < results.length; i = i + 1) {
			if(results[i] === undefined) { return; }
			if(results[i].error) {
				didDispatchCallback = true;
				callback(self, results[i].error);
				return;
			}
			data = data.concat( results[i].data );
		}

		didDispatchCallback = true;
		callback(self, null, data);
	};

	//Public
	self.nextCallback = function() {
		var index,
			ncb;

		index = results.length;
		results.push(undefined);

		ncb = function(e) {
			var i;
			if( results[index] !== undefined ) {
				throw new Error("Task callback can should be dispatched once.");
			}

			results[index] = {
				error : e,
				data : []
			};
			
			for(i = 1; i < arguments.length; i = i + 1) {
				results[index].data.push(arguments[i]);
			}
			
			dispatchCallbackIfComplete();
		};

		return ncb;
	};
	self.cb = self.nextCallback;

	self.push = function(value) {
		self.cb()(null, value);
	};

	self.finalize = function(err) {
		if(isFinalized) {
			return;
		}
		isFinalized = true;
		if(err) {
			criticalError = err;
		}
		dispatchCallbackIfComplete();
	};
};

/**
 * Provides an inteface for a sequence of tasks
 * @class Process
 */
Process = function(fn) {
	//Private
	var self = this,
		active = false,
		ended = false,
		last = {},
		pending = [],
		next, complete;

	next = function(err, data) {
		if(active) { 
			return;
		}
		if(pending.length === 0) {
			last.err = err;
			last.data = data;
			return;
		}
		var task = new Task(complete),
			action = pending.shift(),
			i;

		active = true;
		
		try {
			err = err || last.err || null;
			data = data || last.data || [];
			
			if(action.isEnd) {
				action.fn.apply(null, [err].concat(data));
			}
			else {
				if(action.count > 0 && err === null) {
					for(i = 0; i < data.length; i = i + action.count) {
						action.fn.apply(null, [task, err].concat(data.slice(i, i + action.count)));
					}
				} else {
					action.fn.apply(null, [task, err].concat(data));
				}
			}
			task.finalize();
		}
		catch(e) {
			if(action.isEnd) {
				throw e;
			}
			else {
				task.finalize(e);	
			}
		}
	};

	complete = function(task, err, data) {
		active = false;
		next(err, data);
	};

	//Public
	self.then = function(fn) {
		if(typeof(fn) !== 'function') {
			throw new Error("Invalid argument, function expected.");
		}
		if(ended) {
			throw new Error("Process has ended.");
		}

		pending.push( { fn: fn } );
		next();
		return self;
	};

	self.each = function(fn) {
		if(typeof(fn) !== 'function') {
			throw new Error("Invalid argument, function expected.");
		}
		if(ended) {
			throw new Error("Process has ended.");
		}

		//The following code is derrived from AngularJS (see: http://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically-from-javascript)
		var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
			STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,
			argText, argCount;

		argText = fn.toString().replace(STRIP_COMMENTS, '').match(FN_ARGS)[1];
		argCount = argText.split(',').length - 2;
		if(argCount < 1) { argCount = 1; }
		
		pending.push( { fn: fn, count: argCount } );
		next();
		return self;
	};

	self.end = function(fn) {
		if(typeof(fn) !== 'function') {
			throw new Error("Invalid argument, function expected.");
		}

		pending.push( { fn: fn, isEnd:true } );
		ended = true;
		next();
	};

	self.then(fn);
};

module.exports.start = function(fn) {
	return new Process(fn);
};